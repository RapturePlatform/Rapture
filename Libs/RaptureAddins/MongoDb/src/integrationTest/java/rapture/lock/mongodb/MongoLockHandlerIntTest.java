/**
 * Copyright (C) 2011-2015 Incapture Technologies LLC
 *
 * This is an autogenerated license statement. When copyright notices appear below
 * this one that copyright supercedes this statement.
 *
 * Unless required by applicable law or agreed to in writing, software is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied.
 *
 * Unless explicit permission obtained in writing this software cannot be distributed.
 */
package rapture.lock.mongodb;

import com.github.fakemongo.Fongo;
import com.mongodb.BasicDBObject;
import com.mongodb.DB;
import com.mongodb.DBCollection;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;
import rapture.common.LockHandle;
import rapture.lock.mongodb.MongoLockHandler;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import static org.junit.Assert.*;

public class MongoLockHandlerIntTest {

    private DBCollection collection;
    private MongoLockHandler m;

    @Before
    public void setup() {
        m = new MongoLockHandler();
    }

    @Test
    public void testAcquireLock() {
        String lockHolder = "me";
        String lockName = "//repoIwantto/lock";
        int secondsToWait = 10;
        int secondsToHold = 30;
        LockHandle lockHandle = m.acquireLock(lockHolder, lockName, secondsToWait, secondsToHold);
        assertNotNull(lockHandle);
        assertEquals(lockHolder, lockHandle.getLockHolder());
        assertEquals(lockName, lockHandle.getLockName());
        assertNotNull(lockHandle.getHandle());
        assertTrue(lockExists(lockName, lockHolder));
        assertTrue(m.releaseLock(lockHolder, lockName, lockHandle));
        assertFalse(lockExists(lockName, lockHolder));
    }

    @Test
    public void testAcquireLockMultipleThreads() throws InterruptedException {
        final String lockHolder = "me";
        final String lockName = "//repoThatWillBe/Locked";
        final int secondsToWait = 10;
        final int secondsToHold = 30;

        final Set<LockHandle> handlesAcquired = new HashSet<LockHandle>();
        ExecutorService taskExecutor = Executors.newFixedThreadPool(10);
        for (int i = 0; i < 10; i++) {
            final int counter = i;
            taskExecutor.execute(new Runnable() {
                public void run() {
                    LockHandle lockHandle = m.acquireLock(lockHolder + String.valueOf(counter), lockName, secondsToWait, secondsToHold);
                    assertNotNull(lockHandle);
                    assertTrue(lockExists(lockName, lockHolder + String.valueOf(counter)));
                    handlesAcquired.add(lockHandle);
                    try {
                        Thread.sleep(200);
                    } catch (InterruptedException e) {
                    }
                    assertTrue(m.releaseLock(lockHolder + String.valueOf(counter), lockName, lockHandle));
                    assertFalse(lockExists(lockName, lockHolder + String.valueOf(counter)));
                }
            });
        }
        taskExecutor.shutdown();
        taskExecutor.awaitTermination(5, TimeUnit.SECONDS);
        assertEquals(10, handlesAcquired.size());
    }

    @Ignore
    @Test
    public void testAcquireLockShutout() throws InterruptedException {
        final String lockHolder = "me";
        final String lockName = "//anotherRepo/Locked";
        final int secondsToWait = 1;
        final int secondsToHold = 30;

        final Set<LockHandle> handlesAcquired = new HashSet<LockHandle>();
        final Set<String> handlesDenied = new HashSet<String>();
        ExecutorService taskExecutor = Executors.newFixedThreadPool(10);
        for (int i = 0; i < 10; i++) {
            final int counter = i;
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
            }
            taskExecutor.execute(new Runnable() {
                public void run() {
                    LockHandle lockHandle = m.acquireLock(lockHolder + String.valueOf(counter), lockName, secondsToWait, secondsToHold);
                    if (lockHandle != null) {
                        handlesAcquired.add(lockHandle);
                        assertTrue(lockExists(lockName, lockHolder + String.valueOf(counter)));
                    } else {
                        handlesDenied.add(lockHolder + String.valueOf(counter));
                        // could not get lock, make sure our entry is still not in there
                        assertFalse(lockExists(lockName, lockHolder + String.valueOf(counter)));
                        return;
                    }
                    try {
                        Thread.sleep(2000);
                    } catch (InterruptedException e) {
                    }
                    assertTrue(m.releaseLock(lockHolder + String.valueOf(counter), lockName, lockHandle));
                    assertFalse(lockExists(lockName, lockHolder + String.valueOf(counter)));
                }
            });
        }
        taskExecutor.shutdown();
        taskExecutor.awaitTermination(5, TimeUnit.SECONDS);
        assertEquals(1, handlesAcquired.size());
        assertEquals(9, handlesDenied.size());
    }

    private boolean lockExists(String lockName, String lockHolder) {
        BasicDBObject query = m.getLockQuery(lockName);
        BasicDBObject lock = new BasicDBObject(m.getCtxKey(), lockHolder);
        BasicDBObject match = new BasicDBObject("$elemMatch", lock);
        query.put(m.getLocksKey(), match);
        return m.getLockCollection().find(query).count() > 0;
    }

}
